
### 分库分表
为什么要分库？  
如果业务量剧增，数据库可能会出现性能瓶颈，这时候我们就需要考虑拆分数据库。从这两方面来看：  
- 磁盘存储：业务量剧增，MySQL 单机磁盘容量会撑爆，拆成多个数据库，磁盘使用率大大降低。  
- 并发连接支撑：我们知道数据库连接数是有限的。在高并发的场景下，大量请求访问数据库，MySQL 单机是扛不住的！高并发场景下，会出现 too many connections 报错。

当前非常火的微服务架构出现，就是为了应对高并发。它把订单、用户、商品等不同模块，拆分成多个应用，并且把单个数据库也拆分成多个不同功能模块的数据库（订单库、用户库、商品库），以分担读写压力。

为什么要分表？  
假如你的单表数据量非常大，存储和查询的性能就会遇到瓶颈了，如果你做了很多优化之后还是无法提升效率的时候，就需要考虑做分表了。一般千万级别数据量，就需要分表。  
这是因为即使 SQL 命中了索引，如果表的数据量超过一千万的话，查询也是会明显变慢的。这是因为索引一般是 B+ 树结构，数据千万级别的话，B+ 树的高度会增高，查询就变慢啦。MySQL 的 B+ 树的高度怎么计算的呢？  
InnoDB 存储引擎最小储存单元是页，一页大小就是 16k。B+ 树叶子存的是数据，内部节点存的是键值+指针。索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而再去数据页中找到需要的数据。  
因此单表数据量太大，SQL查询会变慢，所以就需要考虑分表啦。  

什么时候考虑分库分表？  
对于 MySQL，InnoDB 存储引擎的话，单表最多可以存储 10亿级数据。但是的话，如果真的存储这么多，性能就会非常差。一般数据量千万级别，B+ 树索引高度就会到 3 层以上了，查询的时候会多查磁盘的次数，SQL 就会变慢。  
所以，建议单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。我们应该提前规划分库分表，如果估算 3年后，你的表都不会到达这个 500 万，则不需要分库分表。通常，一些流水表、用户表等才考虑分库分表，如果是一些配置类的表，则完全不用考虑，因为不太可能到达这个量级。

如何选择分表键？  
分表键，即用来分库/分表的字段，换种说法就是，你以哪个维度来分库分表的。比如你按用户ID分表、按时间分表、按地区分表，这些用户ID、时间、地区就是分表键。  
一般数据库表拆分的原则，需要先找到业务的主题。比如你的数据库表是一张企业客户信息表，就可以考虑用了客户号做为分表键（因为表是基于客户信息的，所以，需要将同一个客户信息的数据，落到一个表中，避免触发全表路由）。  

非分表键如何查询？  
分库分表后，有时候无法避免一些业务场景，需要通过非分表键来查询。  
假设一张用户表，根据 userId 做分表键，来分库分表。但是用户登录时，需要根据用户手机号来登陆。这时候，就需要通过手机号查询用户信息。而手机号是非分表键。  
非分表键查询，一般有这几种方案：  
- 遍历：最粗暴的方法，就是遍历所有的表，找出符合条件的手机号记录（不建议）  
- 将用户信息冗余同步到ES，同步发送到ES，然后通过ES来查询（推荐）

其实还有基因法：比如非分表键可以解析出分表键出来，比如常见的，订单号生成时，可以包含客户号进去，通过订单号查询，就可以解析出客户号。但是这个场景除外，手机号似乎不适合冗余 userId。


垂直分库、水平分库、垂直分表、水平分表的区别   
- 水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。
- 水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。
- 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
- 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。

### 分表策略
range 范围  
range，即范围策略划分表。比如我们可以将表的主键order_id，按照从0\~300万的划分为一个表，300万~600万划分到另外一个表。
有时候我们也可以按时间范围来划分，如不同年月的订单放到不同的表，它也是一种range的划分策略。  
- 优点： range范围分表，有利于扩容。
- 缺点：可能会有热点问题。因为订单id是一直在增大的，也就是说最近一段时间都是汇聚在一张表里面的。比如最近一个月的订单都在300万~600万之间，平时用户一般都查最近一个月的订单比较多，请求都打到order_1表啦。

hash 取模  
指定的路由 key（一般是user_id、order_id、customer_no作为key）对分表总数进行取模，把数据分散到各个表中。  
一般，我们会取哈希值，再做取余：  
- 优点：hash 取模的方式，不会存在明显的热点问题。
- 缺点：如果未来某个时候，表数据量又到瓶颈了，需要扩容，就比较麻烦。所以一般建议提前规划好，一次性分够。（可以考虑一致性哈希）

一致性 hash  
一致性哈希：在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式哈希表存在的动态伸缩等问题。  

range 范围 + hash 哈希取模避免热点问题数据倾斜（热点数据）  
在拆分库的时候，我们可以先用range范围方案，比如订单id在0\~4000万的区间，划分为订单库1;id在4000万\~8000万的数据，划分到订单库2,将来要扩容时，id在8000万\~1.2亿的数据，划分到订单库3。然后订单库内，再用hash取模的策略，把不同订单划分到不同的表。

### 分库分表中间件
目前流行的分库分表中间件比较多：  
- Sharding-JDBC
- cobar
- Mycat
- Atlas
- TDDL（淘宝）
- vitess


### 分布式事务
常用的分布式事务解决方案有：  
- 两阶段提交
- 三阶段提交
- TCC
- 本地消息表
- 最大努力通知
- saga

### 其他问题
跨节点 Join 关联问题    
跨库Join的几种解决思路：  
- 字段冗余：把需要关联的字段放入主表中，避免关联操作；比如订单表保存了卖家ID（sellerId），你把卖家名字sellerName也保存到订单表，这就不用去关联卖家表了。这是一种空间换时间的思想。
- 全局表：比如系统中所有模块都可能会依赖到的一些基础表（即全局表），在每个数据库中均保存一份。
- 数据抽象同步：比如A库中的a表和B库中的b表有关联，可以定时将指定的表做同步，将数据汇合聚集，生成新的表。一般可以借助ETL工具。
- 应用层代码组装：分开多次查询，调用不同模块服务，获取到数据后，代码层进行字段计算拼装。

分库分表后的分页问题  
方案1（全局视野法）：在各个数据库节点查到对应结果后，在代码端汇聚再分页。这样优点是业务无损，精准返回所需数据；缺点则是会返回过多数据，增大网络传输。  
比如分库分表前，你是根据创建时间排序，然后获取第2页数据。如果你是分了两个库，那你就可以每个库都根据时间排序，然后都返回2页数据，然后把两个数据库查询回来的数据汇总，再根据创建时间进行内存排序，最后再取第2页的数据。  
方案2（业务折衷法-禁止跳页查询）：这种方案需要业务妥协一下，只有上一页和下一页，不允许跳页查询了。  
这种方案，查询第一页时，是跟全局视野法一样的。但是下一页时，需要把当前最大的创建时间传过来，然后每个节点，都查询大于创建时间的一页数据，接着汇总，内存排序返回。

分表要停服嘛？不停服怎么做？  
不用停服。不停服的时候，应该怎么做呢，主要分五个步骤：  
- 编写代理层，加个开关（控制访问新的DAO还是老的DAO，或者是都访问），灰度期间，还是访问老的DAO。
- 发版全量后，开启双写，既在旧表新增和修改，也在新表新增和修改。日志或者临时表记下新表ID起始值，旧表中小于这个值的数据就是存量数据，这批数据就是要迁移的。
- 通过脚本把旧表的存量数据写入新表。
- 停读旧表改读新表，此时新表已经承载了所有读写业务，但是这时候不要立刻停写旧表，需要保持双写一段时间。
- 当读写新表一段时间之后，如果没有业务问题，就可以停写旧表啦

