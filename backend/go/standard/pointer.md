
### Go 指针
传值还是传指针？  
许多开发者认为应该传递 b 或者返回它在一个函数中会更加高效。然而，传递 / 返回的是切片的副本，但是切片本身就是一个引用。所以传递返回切片本身，没有什么区别。  
决定使用指针数组还是值数组归结为你如何使用单个值，而不是你用数组还是映射。
```golang
a := make([]Saiyan, 10)
// 或者
b := make([]*Saiyan, 10)
```

变量的本质对一块内存空间的命名，我们可以通过引用变量名来使用这块内存空间存储的值，而指针则是用来指向这些变量值所在内存地址的值。  
`注：变量值所在内存地址的值不等于该内存地址存储的变量值。`  
```golang
a := 100
var ptr *int  // *声明*指针类型，表示指向存储 int 类型值的指针；当指针被声明后，没有指向任何变量内存地址时，它的零值是 nil
ptr = &a      // *初始化*指针类型值为变量 a (ptr 本身是一个内存地址值，所以需要通过内存地址进行赋值（通过 &a 可以获取变量 a 所在的内存地址）)
fmt.Println(ptr) // 0xc0000a2000
fmt.Println(*ptr) //  *ptr 获取指针指向内存地址存储的变量值 100
fmt.Printf("%p\n", ptr) // 通过 %p 来标识指针类型，输出指针内存地址
fmt.Printf("%d\n", *ptr)

// 还可以通过内置函数 new 声明指针
ptr := new(int)
*ptr = 100
```
Go 语言之所以引入指针类型，主要基于两点考虑，一个是为程序员提供操作变量对应内存数据结构的能力；另一个是为了提高程序的性能（指针可以直接指向某个变量值的内存地址，可以极大节省内存空间，操作效率也更高），这在系统编程、操作系统或者网络应用中是不容忽视的因素。

指针在 Go 语言中有两个典型的使用场景：  
- 类型指针  
- 切片  

作为类型指针时，允许对这个指针类型数据指向的内存地址存储值进行修改，传递数据时如果使用指针则无须拷贝数据从而节省内存空间，此外和 C 语言中的指针不同，Go 语言中的类型指针不能进行偏移和运算，因此更为安全。  
切片类型，由指向数组起始元素的指针、元素数量和容量组成，所以切片与数组不同，是引用类型，而非值类型。  

指针变量在传值时之所以可以节省内存空间，是因为指针指向的内存地址的大小是固定的，在 32 位机器上占 4 个字节，在 64 位机器上占 8 个字节，这与指针指向内存地址存储的值类型无关。  

通过指针传值就类似于 PHP/Java 中通过引用传值，这样做的好处是节省内存空间，此外还可以在调用函数中实现对变量值的修改，因为直接修改的是指针指向内存地址上存储的变量值，而不是值拷贝。
```golang
func swap(a, b int)  {
    a, b = b, a
    fmt.Println(a, b)
}

func main() {
    a := 1
    b := 2
    swap(a, b) // 1 2
    fmt.Println(a, b) // 2 1
}

// 通过指针传值来重构上述代码
func swap(a, b *int)  {
    *a, *b = *b, *a
    fmt.Println(*a, *b)
}

func main() {
    a := 1
    b := 2
    swap(&a, &b) // 2 1
    // 调用完 swap 函数后，它们所对应的内存空间存储值已经交换过来了
    fmt.Println(a, b) // 2 1
}
```

**unsafe.Pointer**  
指针都是被声明为指定类型的，而 unsafe.Pointer 是特别定义的一种指针类型，它可以包含任意类型变量的地址（类似 C 语言中的 void 类型指针）。Go 官方文档对这个类型有如下四个描述：  
- 任何类型的指针都可以被转化为 unsafe.Pointer；  
- unsafe.Pointer 可以被转化为任何类型的指针；  
- uintptr 可以被转化为 unsafe.Pointer；  
- unsafe.Pointer 可以被转化为 uintptr。  

unsafe.Pointer 可以在不同的指针类型之间做转化，从而可以表示任意可寻址的指针类型。  
```golang
i := 10
var p *int = &i

var fp *float32 = (*float32)(unsafe.Pointer(p)) // 将指向 int 类型的指针转化为了 unsafe.Pointer 类型，再转化为 *float32 类型
*fp = *fp * 10
fmt.Println(i)  // 100
```
如上，说明 unsafe.Pointer 是一个万能指针，可以在任何指针类型之间做转化，这就绕过了 Go 的类型安全机制，所以是不安全的操作。  

unsafe.Pointer 还可以与 uintptr 类型之间相互转化。  
uintptr 是 Go 内置的可用于存储指针的整型，而整型是可以进行数学运算的！因此，将 unsafe.Pointer 转化为 uintptr 类型后，就可以让本不具备运算能力的指针具备了指针运算能力。  
```golang
arr := [3]int{1, 2, 3}
// 将数组 arr 的内存地址赋值给指针 ap
ap := &arr

// 通过 unsafe.Pointer 这个桥梁转化为 uintptr 类型，再加上数组元素偏移量（通过 unsafe.Sizeof 函数获取），就可以得到该数组第二个元素的内存地址，最后通过 unsafe.Pointer 将其转化为 int 类型指针赋值给 sp 指针，并进行修改
sp := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(ap)) + unsafe.Sizeof(arr[0])))
*sp += 3
fmt.Println(arr) // [1 5 3]
```
绕过 Go 指针的安全限制，实现对指针的动态偏移和计算，这会导致即使发生数组越界了，也不会报错，而是返回下一个内存地址存储的值，这就破坏了内存安全限制，所以这也是不安全的操作，我们在实际编码时要尽量避免使用，必须使用的话也要非常谨慎。  
