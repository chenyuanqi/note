
### 问题集锦
1、new 和 make 的区别  
二者都是用来做内存分配的。  
new 是 Golang 的内置函数，分配内存的内置函数，第一个参数是类型，而不是具体的值，返回值是该类型的指针。分配的值是该类型零值的指针。  
make 也是用于内存分配的内置函数，但是和 new 不同，make 内置函数分配并初始化一个 slice、map 或 chan 类型的对象。像 new 函数一样，第一个参数是类型，而不是值。  
与 new 不同，make 的返回类型与其参数的类型相同，而不是指向它的指针。结果的取决于传入的类型。并且 slice在 make 的时候，第二个参数必须传递，也就是切片的长度。否则会编译失败。  

2、值类型有哪些?引用类型有哪些？  
基本数据类型都是值类型，包括：int 系列、float 系列、bool、字符串、数组、结构体 struct。  
指针、切片 slice、接口 interface、管道 channel 是引用类型。  
- 值类型在内存中存储的是值本身，而引用类型在内存中存储的是值的内存地址。  
- 值类型内存通常在栈中分配，引用类型内存通常在堆中分配。  

引用类型的内存在堆中分配，当没有任何变量引用堆中的内存地址时，该内存地址对应的数据存储空间就变成了垃圾，就会被 GO 语言的 GC 回收。

3、说说 Go 中的堆和栈  
在 Go 中，栈的内存是由编译器自动进行分配和释放，栈区往往存储着函数参数、局部变量和调用函数帧，它们随着函数的创建而分配，函数的退出而销毁。  
一个 goroutine 对应一个栈，栈是调用栈（call stack）的简称。一个栈通常又包含了许多栈帧（stack frame），它描述的是函数之间的调用关系，每一帧对应一次尚未返回的函数调用，它本身也是以栈形式存放数据。  
与栈不同的是，应用程序在运行时只会存在一个堆。狭隘地说，内存管理只是针对堆内存而言的。程序在运行期间可以主动从堆上申请内存，这些内存通过 Go 的内存分配器分配，并由垃圾收集器回收。  

4、说说 Go 中的深拷贝和浅拷贝  
深拷贝和浅拷贝操作的对象都是 Go 语言中的引用类型。  
引用类型的特点是在内存中存储的是其他值的内存地址；而值类型在内存中存储的是真实的值。  
我们在 go 语言中通过 := 赋值引用类型就是 浅拷贝，即拷贝的是内存地址，两个变量对应的是同一个内存地址对应的同一个值。
```go
a := []string{1,2,3} 
b := a
```
如果我们通过 copy() 函数进行赋值，就是深拷贝，赋值的是真实的值，而非内存地址，会在内存中开启新的内存空间。  
```go
a := []string{1,2,3} 
b := make([]string,len(a),cap(a)) 
copy(b,a)
```

5、说说 Go 的逃逸分析   
参考：https://juejin.cn/post/7131947887398748196  


6、为什么 map 和 slice 是非线性安全的  
在 Go 语言里，map 和 slice 不支持并发读写，也就是是非线性安全的，为什么不支持？  
使用多个 goroutine 对类型为 slice 的变量进行操作，看看结果会变的怎么样。  
```go
func main() {
	var s []string
	for i := 0; i < 9999; i++ {
		go func() {
			s = append(s, "脑子进煎鱼了")
		}()
	}

	fmt.Printf("进了 %d 只煎鱼", len(s))
}
```
无论你执行多少次，每次输出的值大概率都不会一样。也就是追加进 slice 的值，出现了覆盖的情况。这个产生的主要原因是程序逻辑本身就有问题，同时读取到相同索引位，自然也就会产生覆盖的写入了。  
同样，针对类型为 map 的变量进行写入。
```go
func main() {
	s := make(map[string]string)
	for i := 0; i < 99; i++ {
		go func() {
			s["煎鱼"] = "吸鱼"
		}()
	}

	fmt.Printf("进了 %d 只煎鱼", len(s))
}
```
程序运行会直接报错，并发写 map 导致的 fatal error: concurrent map writes 错误提示。  
Go 语言的 sync.Map 支持并发读写 map，采取了 “空间换时间” 的机制，冗余了两个数据结构，分别是：read 和 dirty，减少加锁对性能的影响。  
为什么 map 也不支持线程安全呢？    
- 典型使用场景：map 的典型使用场景是不需要从多个 goroutine 中进行安全访问。  
- 非典型场景（需要原子操作）：map 可能是一些更大的数据结构或已经同步的计算的一部分。  
- 性能场景考虑：若是只是为少数程序增加安全性，导致 map 所有的操作都要处理 mutex，将会降低大多数程序的性能。  
- 总的来讲，就是 Go 官方在经过了长时间的讨论后，认为 Go map 更应适配典型使用场景，而不是为了小部分情况，导致大部分程序付出代价（性能），决定了不支持。  

