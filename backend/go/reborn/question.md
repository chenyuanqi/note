
### 问题集锦
1、new 和 make 的区别  
二者都是用来做内存分配的。  
new 是 Golang 的内置函数，分配内存的内置函数，第一个参数是类型，而不是具体的值，返回值是该类型的指针。分配的值是该类型零值的指针。  
make 也是用于内存分配的内置函数，但是和 new 不同，make 内置函数分配并初始化一个 slice、map 或 chan 类型的对象。像 new 函数一样，第一个参数是类型，而不是值。  
与 new 不同，make 的返回类型与其参数的类型相同，而不是指向它的指针。结果的取决于传入的类型。并且 slice在 make 的时候，第二个参数必须传递，也就是切片的长度。否则会编译失败。  

2、值类型有哪些?引用类型有哪些？  
基本数据类型都是值类型，包括：int 系列、float 系列、bool、字符串、数组、结构体 struct。  
指针、切片 slice、接口 interface、管道 channel 是引用类型。  
- 值类型在内存中存储的是值本身，而引用类型在内存中存储的是值的内存地址。  
- 值类型内存通常在栈中分配，引用类型内存通常在堆中分配。  

引用类型的内存在堆中分配，当没有任何变量引用堆中的内存地址时，该内存地址对应的数据存储空间就变成了垃圾，就会被 GO 语言的 GC 回收。

3、说说 Go 中的堆和栈  
在 Go 中，栈的内存是由编译器自动进行分配和释放，栈区往往存储着函数参数、局部变量和调用函数帧，它们随着函数的创建而分配，函数的退出而销毁。  
一个 goroutine 对应一个栈，栈是调用栈（call stack）的简称。一个栈通常又包含了许多栈帧（stack frame），它描述的是函数之间的调用关系，每一帧对应一次尚未返回的函数调用，它本身也是以栈形式存放数据。  
与栈不同的是，应用程序在运行时只会存在一个堆。狭隘地说，内存管理只是针对堆内存而言的。程序在运行期间可以主动从堆上申请内存，这些内存通过 Go 的内存分配器分配，并由垃圾收集器回收。  

4、说说 Go 中的深拷贝和浅拷贝  
深拷贝和浅拷贝操作的对象都是 Go 语言中的引用类型。  
引用类型的特点是在内存中存储的是其他值的内存地址；而值类型在内存中存储的是真实的值。  
我们在 go 语言中通过 := 赋值引用类型就是 浅拷贝，即拷贝的是内存地址，两个变量对应的是同一个内存地址对应的同一个值。
```go
a := []string{1,2,3} 
b := a
```
如果我们通过 copy() 函数进行赋值，就是深拷贝，赋值的是真实的值，而非内存地址，会在内存中开启新的内存空间。  
```go
a := []string{1,2,3} 
b := make([]string,len(a),cap(a)) 
copy(b,a)
```

5、说说 Go 的逃逸分析   
参考：https://juejin.cn/post/7131947887398748196  


6、为什么 map 和 slice 是非线性安全的  
在 Go 语言里，map 和 slice 不支持并发读写，也就是是非线性安全的，为什么不支持？  
使用多个 goroutine 对类型为 slice 的变量进行操作，看看结果会变的怎么样。  
```go
func main() {
	var s []string
	for i := 0; i < 9999; i++ {
		go func() {
			s = append(s, "脑子进煎鱼了")
		}()
	}

	fmt.Printf("进了 %d 只煎鱼", len(s))
}
```
无论你执行多少次，每次输出的值大概率都不会一样。也就是追加进 slice 的值，出现了覆盖的情况。这个产生的主要原因是程序逻辑本身就有问题，同时读取到相同索引位，自然也就会产生覆盖的写入了。  
同样，针对类型为 map 的变量进行写入。
```go
func main() {
	s := make(map[string]string)
	for i := 0; i < 99; i++ {
		go func() {
			s["煎鱼"] = "吸鱼"
		}()
	}

	fmt.Printf("进了 %d 只煎鱼", len(s))
}
```
程序运行会直接报错，并发写 map 导致的 fatal error: concurrent map writes 错误提示。  
Go 语言的 sync.Map 支持并发读写 map，采取了 “空间换时间” 的机制，冗余了两个数据结构，分别是：read 和 dirty，减少加锁对性能的影响。  
为什么 map 也不支持线程安全呢？    
- 典型使用场景：map 的典型使用场景是不需要从多个 goroutine 中进行安全访问。  
- 非典型场景（需要原子操作）：map 可能是一些更大的数据结构或已经同步的计算的一部分。  
- 性能场景考虑：若是只是为少数程序增加安全性，导致 map 所有的操作都要处理 mutex，将会降低大多数程序的性能。  
- 总的来讲，就是 Go 官方在经过了长时间的讨论后，认为 Go map 更应适配典型使用场景，而不是为了小部分情况，导致大部分程序付出代价（性能），决定了不支持。  


7、切片的初始化问题  
在 Go 语言中，初始化切片时可以选择使用 `make` 函数或不使用它。这两种方法有各自的用途和特点：
#### 使用 `make` 函数
1. **目的**：`make` 主要用于创建一个指定长度和容量的切片。它会分配一个数组，并返回一个引用了它的切片。
2. **语法**：`make([]Type, size, cap)` 其中 `Type` 是切片的元素类型，`size` 是切片的长度，`cap` 是切片的容量。
3. **示例**：
```go
s := make([]int, 5, 10)
```
4. **应用场景**：当你需要一个有固定大小的切片，并且可能在后面的操作中扩展到一个预设的容量时，使用 `make` 是合适的。

#### 不使用 `make` 函数
1. **目的**：直接初始化切片，不预设具体的容量。
2. **语法**：使用字面量来初始化，例如 `[]Type{values...}`。
3. **示例**：
```go
s := []int{1, 2, 3}
```
4. **应用场景**：当你需要初始化一个具有特定值的切片，且不关心其底层的容量时，这种方法是更简洁直接的。

#### 总结
- 使用 `make`：当你需要预分配空间（指定长度和容量），特别是在你知道后续操作可能需要添加更多元素时。
- 不使用 `make`：当你要直接创建并初始化一个切片，且不关心底层的容量大小时。


8、map 的初始化问题 
1. **使用 `make` 初始化 map**： 
   - 使用 `make` 来初始化 map 时，你会创建一个具有指定大小的 map。这是一个非常实用的方法，特别是当你大概知道将要存储多少键值对时。
   - 语法：`m := make(map[keyType]valueType, size)`
   - 例子：`m := make(map[string]int, 100)`
   - 这里，`m` 是一个键类型为 `string`，值类型为 `int` 的 map，其初始分配的空间是 100 个元素。这并不意味着它不能存储超过 100 个元素，而是说在达到 100 个元素之前，不需要重新分配更多的内存。

2. **不使用 `make` 初始化 map**：  
   - 当你直接声明一个 map 而不使用 `make` 时，创建的是一个 nil map。这种 map 不能直接用于存储键值对，需要在使用前通过 `make` 初始化。
   - 语法：`var m map[keyType]valueType`
   - 例子：`var m map[string]int`
   - 在这种情况下，`m` 是一个 `nil` map。如果你尝试在不先使用 `make` 初始化的情况下向它添加键值对，程序将触发运行时错误（panic）。

**要点**：
- 如果你提前知道 map 的大致大小，使用 `make` 初始化是个好主意，这样可以提高性能，因为 Go 不需要在 map 增长时不断重新分配内存。
- 如果你不确定 map 的大小，或者仅仅是声明一个 map 以备后用，你可以先声明一个 nil map，然后在需要的时候使用 `make` 对其进行初始化。直接声明一个 nil map（即不使用 make）可以更有效地使用内存，因为实际的内存分配被推迟到你真正需要使用这个 map 的时候。  
- 无论使用哪种方法，都不能向 nil map 中添加元素，因为这会导致运行时错误。所以，在添加任何元素之前，请确保 map 已经被初始化。

当你使用 `make` 初始化一个 Go 语言中的 map 时，你可以选择是否指定初始容量。这两种方式有各自的特点和适用场景：
- **不指定长度**：适用于元素数量不确定或数量较少的情况。Go 运行时会根据需要动态分配内存。
- **指定长度**：适用于你已经知道大概需要存储多少元素，或者关注性能优化的场景。通过减少内存重新分配的次数来提高性能。


9、结构体的初始化问题  
1. **使用字段名称初始化**：在初始化结构体时，最好指定字段名称。这使代码更易读，也更容易维护。例如：
```go
type User struct {
   Name string
   Age  int
}

u := User{Name: "John", Age: 30}
```
2. **构造函数**：考虑为结构体定义一个或多个构造函数。这对于封装初始化逻辑特别有用，尤其是在需要进行复杂初始化或设置默认值时。
   ```go
func NewUser(name string, age int) *User {
   return &User{
       Name: name,
       Age:  age,
   }
}
```
3. **指针与值类型**：根据需要选择返回结构体的指针还是值。指针可以避免复制整个结构体，节省内存，但也需要考虑空指针的风险。值类型更简单，但可能涉及更多的内存拷贝。
4. **使用`new`关键字**：虽然不常见，但可以使用`new`关键字创建结构体的指针。这会分配结构体所需的内存并返回指向它的指针。字段将被初始化为零值。
```go
u := new(User)
```
5. **避免过度封装**：虽然构造函数很有用，但不要为了封装而封装。在 Go 中，直接使用结构体并不罕见。
6. **考虑可选字段**：对于有默认值的字段，可以在构造函数中设置它们。对于可选的或有默认值的字段，可以考虑使用结构体作为参数的变体，如使用函数选项模式。
7. **结构体内部验证**：在构造函数中或在结构体方法内部添加验证逻辑，确保结构体的状态始终有效。
8. **不变性**：如果可能，尽量使结构体不可变，这意味着一旦创建就不允许更改其字段。这可以通过不暴露字段本身，而是只提供获取字段值的方法来实现。
9. **文档化**：为结构体及其构造函数提供清晰的文档说明，特别是在公共API或库中，这对于其他开发者理解你的代码非常重要。



