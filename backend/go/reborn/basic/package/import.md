
### Go import
可以在一个 Go 语言源文件包声明语句之后，其它非导入声明语句之前，包含零到多个导入包声明语句。每个导入声明可以单独指定一个导入路径，也可以通过圆括号同时导入多个导入路径。要引用其他包的标识符，可以使用 import 关键字，导入的包名使用双引号包围，包名是从 GOPATH 开始计算的路径，使用 / 进行路径分隔。

导入有两种基本格式，即单行导入和多行导入，两种导入方法的导入代码效果是一致的。  
```go
// 单行导入
import "包1"
import "包2"

// 多行导入时，包名在 import 中的顺序不影响导入效果
import(
    "包1"
    "包2"
    …
)

// 导入同一目录下 test 包中的内容
import "./test"
// 导入 fmt，并给他启别名 f
import f "fmt"
// 将 fmt 导入并启用别名 "."，这样就可以直接使用其内容，而不用再添加 fmt，如 fmt.Println 可以直接写成 Println
import . "fmt"
// 表示不使用该包，而是只是使用该包的 init 函数，并不显示的使用该包的其他内容。
// 注意：这种形式的 import，当 import 时就执行了 fmt 包中的 init 函数，而不能够使用该包的其他函数。
import _ "fmt"
```

导入的包之间可以通过添加空行来分组；通常将来自不同组织的包独自分组。包的导入顺序无关紧要，但是在每个分组中一般会根据字符串顺序排列。
```go
import (
    "fmt"
    "html/template"
    "os"

    "golang.org/x/net/html"
    "golang.org/x/net/ipv4"
)
```

**导入包后自定义引用的包名**  
如果我们想同时导入两个有着名字相同的包，例如 math/rand 包和 crypto/rand 包，那么导入声明必须至少为一个同名包指定一个新的包名以避免冲突。这叫做导入包的重命名。  
```go
import (
    "crypto/rand"
    mrand "math/rand" // 将名称替换为 mrand 避免冲突
)
```
导入包的重命名只影响当前的源文件。其它的源文件如果导入了相同的包，可以用导入包原本默认的名字或重命名为另一个完全不同的名字。

导入包重命名是一个有用的特性，它不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便。选择用简短名称重命名导入包时候最好统一，以避免包名混乱。选择另一个包名称还可以帮助避免和本地普通变量名产生冲突。例如，如果文件中已经有了一个名为 path 的变量，那么我们可以将"path"标准包重命名为 pathpkg。

每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的情况，Go 语言的构建工具将报告错误。

**匿名导入包——只导入包但不使用包内类型和数值**  
如果只希望导入包，而不使用任何包内的结构和类型，也不调用包内的任何函数时，可以使用匿名导入包
```go
import (
    _ "path/to/package"
)
```
匿名导入的包与其他方式导入包一样会让导入包编译到可执行文件中，同时，导入包也会触发 init() 函数调用。

**包在程序启动前的初始化入口：init**  
在某些需求的设计上需要在程序启动时统一调用程序引用到的所有包的初始化函数，如果需要通过开发者手动调用这些初始化函数，那么这个过程可能会发生错误或者遗漏。我们希望在被引用的包内部，由包的编写者获得代码启动的通知，在程序启动时做一些自己包内代码的初始化工作。

Go 语言提供了一个非常方便的特性：init() 函数。init() 函数的特性如下：
- 每个源码可以使用 1 个 init() 函数。
- init() 函数会在程序执行前（main() 函数执行前）被自动调用。
- 调用顺序为 main() 中引用的包，以深度优先顺序初始化。
- 同一个包中的多个 init() 函数的调用顺序不可预期。
- init() 函数不能被其他函数调用。

**理解包导入后的 init() 函数初始化顺序**  
Go 语言包会从 main 包开始检查其引用的所有包，每个包也可能包含其他的包。Go 编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。  
在运行时，被最后导入的包会最先初始化并调用 init() 函数。
```go
import "test/pkg1" // 导入 pkg1 包
func main() {
    pkg1.ExecPkg1()
    // pkg2 init
    // pkg1 init
    // ExecPkg1
    // ExecPkg2
}

package pkg1
func ExecPkg1() {
    fmt.Println("ExecPkg1")
    pkg2.ExecPkg2()
}
func init() {
    fmt.Println("pkg1 init")
}

package pkg2
import "fmt"
func ExecPkg2() {
    fmt.Println("ExecPkg2")
}
func init() {
    fmt.Println("pkg2 init")
}
```
