
### GPM 任务调度
Go 语言中的 GPM 任务调度模型充分利用了多核 CPU 的资源。需要时，将创建与之匹配的线程，并将用户态的协程任务 “智能” 地分配给多个线程执行。  
- M：内核级线程，即工作线程，在 Go 中称为 Machine，数量对应真实的 CPU 数（真正干活的对象）。  
- G：代表一个 goroutine，即 Go 协程，每个 go 关键字都会创建一个协程。  
- P：Processor，处理器，用来管理和执行 goroutine 的。包含运行 Go 代码的必要资源，用来调度 G 和 M 之间的关联关系，其数量可通过 GOMAXPROCS () 来设置，默认为核心数。

在 Go 程序启动时，会自动根据 CPU 的核心数设置线程的最大数量。当然，我们也可以通过编码手动设置。当一个线程发生阻塞时，新的线程便会创建。  
全局队列存放所有等待运行的协程任务（即 Goroutine）。当发起一个协程任务时，该任务会首先尝试加入到协程队列中。每个协程队列的最大任务数被限制在 256 个以内。 当协程队列满了之后，协程调度器会将一半数量的任务移动至全局队列中。至于一共能有多少个协程队列，在 Go 1.5 版本之后队列数默认为 CPU 核心数量，也可以通过编码来指定。从另一个角度讲，设置了队列数就意味着设置了程序能同时跑多少个 Goroutine 的数量。一般地，在该参数确定后，所有的队列便会一口气创建完成。  
在 Go 程序运行时，一个内核空间的线程若想获取某个协程任务来执行，就需要通过协程队列处理来获取特定的协程任务。当队列为空时，全局队列中的若干协程任务，或其它队列中的一半任务会被放到空队列中。如此循环往复，周而复始。  
另一方面，协程队列处理器的数量和线程在数量上并没有绝对关系。如果一个线程发生阻塞，协程队列处理器便会创建或切换至其它线程。因此，即使只有一个协程队列，也有可能会有多个线程。  


**Goroutine 调度策略**  
队列轮转：P 会周期性的将 G 调度到 M 中执行，执行一段时间后，保存上下文，将 G 放到队列尾部，然后从队列中再取出一个 G 进行调度。除此之外，P 还会周期性的查看全局队列是否有 G 等待调度到 M 中执行。  
系统调用：当 G0 即将进入系统调用时，M0 将释放 P，进而某个空闲的 M1 获取 P，继续执行 P 队列中剩下的 G。M1 的来源有可能是 M 的缓存池，也可能是新建的。  
当 G0 系统调用结束后，如果有空闲的 P，则获取一个 P，继续执行 G0。如果没有，则将 G0 放入全局队列，等待被其他的 P 调度。然后 M0 将进入缓存池睡眠。  


**动态调整系统资源**  
在 Go 程序运行时，可以根据需要设置程序要使用的 CPU 资源，也可以动态调整协程任务的执行方式，实现更灵活地运行。这些操作都是通过 runtime 包来实现的。

```go
// 获取运行当前程序的操作系统
// 在 macOS 中，操作系统名称为 darwin；在 Windows 中，操作系统名称即 windows；在 Linux 中，操作系统名称为 linux
fmt.Println(runtime.GOOS)
// 获取运行当前程序的CPU架构
fmt.Println(runtime.GOARCH)
// 获取运行当前程序的CPU核心数量
// 对于 32 位的 CPU，运行结果为 386；对于 64 位的 CPU，运行结果为 amd64；对于 arm 架构 32 位的 CPU，运行结果为 arm；对于 arm 架构 64 位的 CPU，运行结果为 arm64
fmt.Println(runtime.NumCPU())

// 设置程序只能使用一半数量的核心
if runtime.NumCPU() > 2 {
   runtime.GOMAXPROCS(runtime.NumCPU() / 2)
}
// 获取当前程序可用的CPU核心数
fmt.Println(runtime.GOMAXPROCS(0))
```

