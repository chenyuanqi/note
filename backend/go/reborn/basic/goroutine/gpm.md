
### GPM 任务调度
Go 语言中的 GPM 任务调度模型充分利用了多核 CPU 的资源。需要时，将创建与之匹配的线程，并将用户态的协程任务 “智能” 地分配给多个线程执行。  

在 Go 程序启动时，会自动根据 CPU 的核心数设置线程的最大数量。当然，我们也可以通过编码手动设置。当一个线程发生阻塞时，新的线程便会创建。  
全局队列存放所有等待运行的协程任务（即 Goroutine）。当发起一个协程任务时，该任务会首先尝试加入到协程队列中。每个协程队列的最大任务数被限制在 256 个以内。 当协程队列满了之后，协程调度器会将一半数量的任务移动至全局队列中。至于一共能有多少个协程队列，在 Go 1.5 版本之后队列数默认为 CPU 核心数量，也可以通过编码来指定。从另一个角度讲，设置了队列数就意味着设置了程序能同时跑多少个 Goroutine 的数量。一般地，在该参数确定后，所有的队列便会一口气创建完成。  
在 Go 程序运行时，一个内核空间的线程若想获取某个协程任务来执行，就需要通过协程队列处理来获取特定的协程任务。当队列为空时，全局队列中的若干协程任务，或其它队列中的一半任务会被放到空队列中。如此循环往复，周而复始。  
另一方面，协程队列处理器的数量和线程在数量上并没有绝对关系。如果一个线程发生阻塞，协程队列处理器便会创建或切换至其它线程。因此，即使只有一个协程队列，也有可能会有多个线程。  

**动态调整系统资源**  
在 Go 程序运行时，可以根据需要设置程序要使用的 CPU 资源，也可以动态调整协程任务的执行方式，实现更灵活地运行。这些操作都是通过 runtime 包来实现的。

```go
// 获取运行当前程序的操作系统
// 在 macOS 中，操作系统名称为 darwin；在 Windows 中，操作系统名称即 windows；在 Linux 中，操作系统名称为 linux
fmt.Println(runtime.GOOS)
// 获取运行当前程序的CPU架构
fmt.Println(runtime.GOARCH)
// 获取运行当前程序的CPU核心数量
// 对于 32 位的 CPU，运行结果为 386；对于 64 位的 CPU，运行结果为 amd64；对于 arm 架构 32 位的 CPU，运行结果为 arm；对于 arm 架构 64 位的 CPU，运行结果为 arm64
fmt.Println(runtime.NumCPU())

// 设置程序只能使用一半数量的核心
if runtime.NumCPU() > 2 {
   runtime.GOMAXPROCS(runtime.NumCPU() / 2)
}
// 获取当前程序可用的CPU核心数
fmt.Println(runtime.GOMAXPROCS(0))
```

