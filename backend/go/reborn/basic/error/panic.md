
### panic：运行时恐慌
panic，运行时恐慌。  
比如说，一个 Go 程序里有一个切片，它的长度是 5，也就是说该切片中的元素值的索引分别为 0、1、2、3、4，但是，我在程序里却想通过索引 5 访问其中的元素值，显而易见，这样的访问是不正确的。Go 程序，确切地说是程序内嵌的 Go 语言运行时系统，会在执行到这行代码的时候抛出一个 “index out of range” 的 panic，用以提示你索引越界了。这不仅仅是个提示。当 panic 被抛出之后，如果我们没有在程序里添加任何保护措施的话，程序（或者说代表它的那个进程）就会在打印出 panic 的详细情况（以下简称 panic 详情）之后，终止运行。  
```bash
# panic 详情
panic: runtime error: index out of rangegoroutine 1 [running]:main.main() /Users/haolin/GeekTime/Golang_Puzzlers/src/puzzlers/article19/q0/demo47.go:5 +0x3dexit status 2
```

从 panic 被引发到程序终止运行的大致过程是什么？  
某个函数中的某行代码有意或无意地引发了一个 panic。这时，初始的 panic 详情会被建立起来，并且该程序的控制权会立即从此行代码转移至调用其所属函数的那行代码上，也就是调用栈中的上一级。这也意味着，此行代码所属函数的执行随即终止。紧接着，控制权并不会在此有片刻的停留，它又会立即转移至再上一级的调用代码处。控制权如此一级一级地沿着调用栈的反方向传播至顶端，也就是我们编写的最外层函数那里。  
这里的最外层函数指的是 go 函数，对于主 goroutine 来说就是 main 函数。但是控制权也不会停留在那里，而是被 Go 语言运行时系统收回。随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡并消失。与此同时，在这个控制权传播的过程中，panic 详情会被逐渐地积累和完善，并会在程序终止之前被打印出来。  

Go 语言的内建函数 panic 是专门用于引发 panic 的。panic 函数使程序开发者可以在程序运行期间报告异常。  
`注意，这与从函数返回错误值的意义是完全不同的。当我们的函数返回一个非 nil 的错误值时，函数的调用方有权选择不处理，并且不处理的后果往往是不致命的。`
panic 不是一件很好的事情，可能造成体验停止、服务中断，就像没有人希望在取钱时遇到 ATM 机蓝屏一样，但是，如果在损失发生时，程序没有因为恐慌而停止，那么用户将会付出更大的代价，这种代价可以是金钱、时间甚至生命，因此，panic 有时也是一种合理的止损方法。  
一般而言，当 panic 发生时，程序会中断运行，并立即执行在该 goroutine（可以先理解成线程）中被延迟的函数（defer 机制），随后，程序崩溃并输出日志信息，日志信息包括 panic value 和函数调用的堆栈跟踪信息，panic value 通常是某种错误信息。  
对于每个 goroutine，日志信息中都会有与之相对的，发生 panic 时的函数调用堆栈跟踪信息，通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据，因此，在我们填写问题报告时，一般会将 panic 和日志信息一并记录。  
虽然 Go 语言的 panic 机制类似于其他语言的异常，但 panic 的适用场景有一些不同，由于 panic 会引起程序的崩溃，因此 panic 一般用于严重错误，如程序内部的逻辑不一致。任何崩溃都表明了我们的代码中可能存在漏洞，所以对于大部分漏洞，我们应该使用 Go 语言提供的错误机制，而不是 panic。  

Go 的错误处理机制是由两个部分组成的，panic 代表着特殊的（或者说意外的）错误，error 代表着普通的错误。与 try-catch 不同，error 并不是打断正常的控制流程的执行。单单这一点来讲，就已经是非常好的进步了。相比之下，panic 会打断正常的控制流程。从这一点上看，panic 与 try-catch 很像。  
try-catch 是一套行为单一的错误处理机制，而 Go 语言的（error+panic）把错误处理机制在代码级别分为了两个部分。这样的好处是，倒逼开发者去思考，什么时候应该返回普通的错误，什么时候应该抛出意外的错误。这种思考在设计一个程序的错误体系的时候是非常重要的，关系到程序运行的稳定性。至于缺点，error 容易被滥用，导致程序中到处是 if err != nil 的代码。但是我们要清楚的是，这往往是程序设计上的问题，而不是语言层面的问题。如果不当心，try-catch 照样会被弄的满屏都是。而且 try-catch 还有一个颗粒度和数量的问题（与临界区的颗粒度和数量问题类似）。  
总之，Go 语言的错误处理机制是一种创新和进步。不过，由于容易被滥用，Go 语言团队不是还在近几年一直在考虑更好的解决方案吗。很期待他们新的设计。   

**手动触发恐慌**  
Go 语言可以在程序中手动触发恐慌，让程序崩溃，这样开发者可以及时地发现错误，同时减少可能的损失。Go 语言程序在恐慌时，会将堆栈和 goroutine 信息输出到控制台，所以恐慌也可以方便地知晓发生错误的位置。  
```go
// panic() 的声明
func panic(v interface{})    //panic() 的参数可以是任意类型的

package main
func main() {
    panic("crash")
}
// panic: crash

// goroutine 1 [running]:
// main.main()
//     D:/code/main.go:4 +0x40
// exit status 2
```

**在运行依赖的必备资源缺失时主动触发恐慌**  
regexp 是 Go 语言的正则表达式包，正则表达式需要编译后才能使用，而且编译必须是成功的，表示正则表达式可用。

编译正则表达式函数有两种，具体如下：
1) func Compile(expr string) (*Regexp, error)  
编译正则表达式，发生错误时返回编译错误同时返回 Regexp 为 nil，该函数适用于在编译错误时获得编译错误进行处理，同时继续后续执行的环境。  
2) func MustCompile(str string) *Regexp  
当编译正则表达式发生错误时，使用 panic 触发恐慌，该函数适用于直接使用正则表达式而无须处理正则表达式错误的情况。  
```go
func MustCompile(str string) *Regexp {
    regexp, error := Compile(str)
    if error != nil {
        panic(`regexp: Compile(` + quote(str) + `): ` + error.Error())
    }
    return regexp
}
```
手动恐慌进行报错的方式不是一种偷懒的方式，反而能迅速报错，终止程序继续运行，防止更大的错误产生，不过，如果任何错误都使用恐慌处理，也不是一种良好的设计习惯，因此应根据需要来决定是否使用恐慌进行报错。

**在恐慌时触发延迟执行语句**  
当 panic() 触发的恐慌发生时，panic() 后面的代码将不会被运行，但是在 panic () 函数前面已经运行过的 defer 语句依然会在恐慌发生时发生作用。
```go
package main
import "fmt"
func main() {
    defer fmt.Println("恐慌后要做的事情1")
    defer fmt.Println("恐慌后要做的事情2")
    panic("恐慌")
}
// 恐慌后要做的事情 2
// 恐慌后要做的事情 1
// panic: 恐慌

// goroutine 1 [running]:
// main.main()
//     D:/code/main.go:8 +0xf8
// exit status 2
```

