
### 二分查找
对于基于数字索引的数组元素的查找，我们可能第一反应都是遍历这个数组，直到给定数组元素值和待查找的值相等时，返回索引值并退出，否则一直遍历到最后一个元素，如果还是没有找到则返回-1，这样的查找虽然是简单粗暴了点，但是对于规模不大的数据集，也是没什么问题的，但是很明显，对于n个元素的数组，这种查找的时间复杂度是 O(n)，随着数据规模的增加，性能会越来越差，设想如果数据集的长度是 40 亿（约2的32次方），那么最差的情况需要遍历数组 40 亿次！  

所谓二分查找，针对的是一个有序的数据集合（这点很重要），查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。注意到二分查找针对的必须是已经排序过的有序数组，否则不能使用该算法。  

二分查找的时间复杂度是 O(logn)。这是一个非常恐怖的数量级，有时候甚至比 O(1) 还要高效，比如我们要在开头提到的 40 亿个数字中查找某一个元素，也只需要32次（2的32次方是40亿数量级），这真的是非常高效了，正因如此，二分查找在线性表结构中的应用非常广泛。但是使用二分查找需要注意一个前提，那就是针对有序数组，换言之，二分查找适用于变动不是很频繁的静态序列集，如果序列集变动很频繁，经常进行插入删除操作，那么就要不断维护这个序列集的排序，这个成本也很高，因此，这种情况下就不适用二分查找了，比如我们的数据库查询，增删改查很频繁，显然不是通过二分查找来进行查询的。  
```php
function binary_search($arr, $num){
    $arr_length = count($arr);
    if ($arr_length <= 1) {
        return 0;
    }

    return binary_search_internal($arr, $num, 0, $arr_length - 1);
}

function binary_search_internal($arr, $num, $low, $high){
    if ($low > $high) {
        return -1;
    }

    $mid = floor(($low + $high) / 2);
    if ($num > $arr[$mid]) {
        return binary_search_internal($arr, $num, $mid + 1, $high);
    } elseif ($num < $arr[$mid]) {
        return binary_search_internal($arr, $num, $low, $mid - 1);
    } else {
        return $mid;
    }
}
```
