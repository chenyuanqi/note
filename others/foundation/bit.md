# 整数在计算机中的表示方式

## 计算机中的二进制

计算机采用的是二进制，二进制包括两个数码：0,1。

一位二进制数的可能取值有 2 个，k 位二进制数的可能取值就有 ![img](https://cdn.nlark.com/yuque/__latex/fe401f62231ac24e3399751a415a4eaa.svg)个。



在计算机中有多种数据类型，表示整数的数据类型就有好几种：

- 1 字节数（1byte=8bit），即 8 位二进制数，可能取值有 ![img](https://cdn.nlark.com/yuque/__latex/b6e88755e42c2c1e895de7cb3bb09cf6.svg)个；
- 2 字节数，即 16 位二进制数，可能取值有 ![img](https://cdn.nlark.com/yuque/__latex/3ca2a55527f9b3df8d7e4b849a6c7b68.svg) 个；
- 4 字节数，即 32 位二进制数，可能取值有 ![img](https://cdn.nlark.com/yuque/__latex/f19901f1c817ad846a411e6712e8db66.svg)个；
- 8 字节数，即 64 位二进制数，可能取值有 ![img](https://cdn.nlark.com/yuque/__latex/5212463e37406b73b693fe832f7bc8c2.svg)个。



## 有符号整数和无符号整数

计算机中的数据类型包括有符号类型和无符号类型，有符号类型的整数称为有符号整数，无符号类型的整数称为无符号整数。



有符号整数中，最高位用于表示符号，因此最高位又称符号位。当最高位是 0 时表示 0 或正整数，当最高位是 1 时表示负整数。除了最高位以外的数位用于表示数字的大小。



无符号整数中，所有的数位都用于表示数字的大小，因此无符号整数不存在负数。



以 1 字节数为例，1 字节数包含 8位二进制数。



对于 1字节的有符号整数，当最高位是 0 时，1 字节数的取值范围是 0 到 127（即 ![img](https://cdn.nlark.com/yuque/__latex/81e2b04734b0651cece2aa0d9908f9a4.svg)），当最高位是 1时，1 字节数的取值范围是 -128（即 ![img](https://cdn.nlark.com/yuque/__latex/658ce9b75e22c565ec1249cd38495066.svg) ）到 −1。因此 1 字节的有符号整数的取值范围是 −128 到 127，即对于有符号的 8 位二进制数，取值范围是 ![img](https://cdn.nlark.com/yuque/__latex/658ce9b75e22c565ec1249cd38495066.svg)到 ![img](https://cdn.nlark.com/yuque/__latex/81e2b04734b0651cece2aa0d9908f9a4.svg)。



对于 1 字节的无符号整数，可能的最小取值是 0，最大取值是 255（即 ![img](https://cdn.nlark.com/yuque/__latex/47d991cc7ab741c483dde4d37e9b25de.svg)），即对于无符号的 8 位二进制数，取值范围是 0 到 ![img](https://cdn.nlark.com/yuque/__latex/47d991cc7ab741c483dde4d37e9b25de.svg)。



通过上述例子可以得到有符号整数和无符号整数的如下结论：

- 有符号整数的取值范围包括负整数、零与正整数，无符号整数的取值范围只包括零与正整数，不包括负整数；
- 在位数相同的情况下，有符号整数可以表示的最大值比无符号整数小了一半；
- 对于 k 位整数，有符号整数的取值范围是 ![img](https://cdn.nlark.com/yuque/__latex/133ec994405ecb77884cddc7a661d04c.svg) 到 ![img](https://cdn.nlark.com/yuque/__latex/693fc0c0ba054ae3c86235ad787751cd.svg)，无符号整数的取值范围是 0 到 ![img](https://cdn.nlark.com/yuque/__latex/458a9216b81aa45a64505a870735d44a.svg)。

## 原码、补码和反码

### 机器数和真值

在讲述原码、补码和反码的概念之前，需要先了解两个概念：机器数和真值。



一个数在计算机中的二进制表示形式称为这个数的机器数。机器数是有符号数，机器数的最高位是符号位，0 表示0或正数，1 表示负数。



以 8 位二进制数为例。十进制数 `+10`转换成二进制数是 00001010，十进制数 `-10` 转换成二进制数是 10001010。这里的 00001010 和 10001010 就是机器数。



因为机器数的最高位是符号位，所以机器数的形式值不一定等于真正数值。例如 10001010 的形式值是 138，真正数值是 −10，形式值和真正数值是不同的。为了加以区分，将机器数的真正数值称为机器数的真值。



例如，00000010 的真值是 +2，10000010 的真值是 −2。



### 原码、反码和补码的概念

#### 原码

原码是机器数的符号位加上机器数的真值的绝对值，最高位是符号位，其余位表示数值。

以 8 位二进制数为例。+10 的原码是 00001010，−10 的原码是 10001010。



8 位二进制数的原码表示的最大值是 01111111，即十进制的 +127，最小值是 11111111，即十进制的 −127，因此 8 位二进制数的原码表示的取值范围是 −127 到 +127。



原码是人脑最容易理解和计算的表示方式。



#### 反码

反码在原码的基础上得到。

0和正数的反码与原码相同，负数的反码是将原码的除了**符号位之外的每一位取反**，取反即是将 0 变成 1 或将 1 变成 0。



以 8 位二进制数为例。

+10 的原码是 00001010，反码是 00001010；

−10 的原码是 10001010，反码是 11110101。



对于负数，反码的表示方式不直观，通常需要转换成原码才能计算其数值。



#### 补码

补码在反码的基础上得到。

0 和正数的补码与原码、反码相同，负数的补码是在反码的基础上加 1 得到。



以 8 位二进制数为例。



+10 的原码是 00001010，反码是 00001010，补码是 00001010；

−10 的原码是 10001010，反码是 11110101，补码是 11110110。



对于负数，补码的表示方式不直观，通常需要转换成原码才能计算其数值。



## 计算机中的表示

至此，我们已经看到计算机中的有符号数的二进制表示有原码、反码和补码三种表示方法，这三种表示方法分别有什么优缺点呢？



人脑可以知道最高位是符号位，但是对于计算机而言，判断符号位将导致运算变得复杂，因此为了简化运算，人们想出了将符号位也参与运算的方法。



**原码**是人脑最容易理解和计算的表示方式，但是原码存在两个问题：

- 同时存在 +0（即符号位和其余位都是 0）和 −0（即符号位是 1，其余位都是 0）的表示，虽然可以认为 +0 和 −0 是同一个数，但是 0 带符号是没有意义的，而且会导致有两个不同的原码都对应 0；
- 用原码进行减法运算，会导致错误的结果。



**反码**的引入，解决了原码的减法运算结果错误的问题，但是仍然没有解决同时存在 +0 和 -0 的问题。



**补码**的引入则同时解决了减法运算错误和同时存在 +0 和 -0 的问题，而且可以多表示一个最小值。在补码表示法中，不存在 -0 的情况。以 8位二进制数为例，0 的补码是 00000000，10000000 表示的是 -128，-128 没有原码和反码的表示（8 位二进制数的原码和反码能表示的最小值是 -127）。由此可见，补码不仅解决了原码和反码的问题，还可以多表示一个最小值。



由于补码具有上述优点，因此计算机采用补码进行运算。


# 位运算符的概念和性质

## 位运算概述

计算机采用的是二进制，二进制包括两个数码：0,1。在计算机的底层，一切运算都是基于位运算实现的。



位运算共有 6 种，分别是：与、或、异或、取反、左移和右移，其中左移和右移统称移位运算，移位运算又分为算术移位和逻辑移位。上述位运算中，只有取反是一元运算，其余的都是二元运算。

### 与、或、异或和取反

与运算的符号是 &，运算规则是：对于每个二进制位，当两个数对应的位都为 1 时，结果才为 1，否则结果为 0。

![img](https://cdn.nlark.com/yuque/__latex/c515c23aafd8192c2c1d43901cf22ac8.svg)



或运算的符号是 ∣，运算规则是：对于每个二进制位，当两个数对应的位都为 0 时，结果才为 0，否则结果为 1。



![img](https://cdn.nlark.com/yuque/__latex/689be03785be17258c2e5c08b5526ea9.svg)



异或运算的符号是 ![img](https://cdn.nlark.com/yuque/__latex/61a41642d26f221806dcbccfcebc2ef8.svg)（在代码中用 **∧** 表示异或），运算规则是：对于每个二进制位，当两个数对应的位相同时，结果为 0，否则结果为 1。



![img](https://cdn.nlark.com/yuque/__latex/04f810347d4a3555d9d4af955706288b.svg)





取反运算的符号是 ![img](https://cdn.nlark.com/yuque/__latex/6588c95074f2609674f5fe10ab63f88f.svg)，运算规则是：对一个数的每个二进制位进行取反操作，0 变成 1，1 变成 0。



![img](https://cdn.nlark.com/yuque/__latex/1fa55730acda5de4fe2ffa5d842db33d.svg)



以下例子显示上述四种位运算符的运算结果，参与运算的数字都采用有符号的 8 位二进制表示。

46 的二进制表示是 00101110，51 的二进制表示是 00110011。考虑以下位运算的结果。

- 46 & 51 的结果是 34，对应的二进制表示是 00100010。
- 46 ∣ 51 的结果是 63，对应的二进制表示是 00111111。
- 46⊕51 的结果是 29，对应的二进制表示是 00011101。
- 46∼46 的结果是 −47，对应的二进制表示是 11010001。
- 51∼51 的结果是 -52，对应的二进制表示是 11001100。



### 移位运算

移位运算按照移位方向分类可以分成**左移**和**右移**，按照是**否带符号**分类可以分成**算术移位（带符号）**和**逻辑移位（不带符号）**。



左移运算的符号是 <<。左移运算时，将全部二进制位向左移动若干位，高位丢弃，低位补 0。对于左移运算，算术移位和逻辑移位是相同的。



右移运算的符号是 >>。右移运算时，将全部二进制位向右移动若干位，低位丢弃，高位的补位由算术移位或逻辑移位决定：

- 算术右移时，高位补最高位；
- 逻辑右移时，高位补 0。



以下例子显示移位运算的运算结果，参与运算的数字都采用有符号的 8 位二进制表示。

29 的二进制表示是 00011101。29 左移 2 位的结果是 116，对应的二进制表示是 01110100；29 左移 3 位的结果是 -24，对应的二进制表示是 11101000。



50 的二进制表示是 00110010。50 右移 1 位的结果是 25，对应的二进制表示是 00011001；50 右移 2 位的结果是 12，对应的二进制表示是 00001100。对于 0 和正数，算术右移和逻辑右移的结果是相同的。



-50 的二进制表示是 11001110。-50 算术右移 2 位的结果是 -13，对应的二进制表示是 11110011；-50 逻辑右移 2 位的结果是 51，对应的二进制表示是 00110011。



右移运算中的算术移位和逻辑移位是不同的，计算机内部的右移运算采取的是哪一种呢？



对于C/C++ 而言，数据类型包含有符号类型和无符号类型，其中有符号类型使用关键字 **signed** 声明，无符号类型使用关键字**unsigned** 声明，两个关键字都不使用时，默认是有符号类型。对于有符号类型，右移运算为算术右移；对于无符号类型，右移运算为逻辑右移。



对于 **Java** 而言，不存在无符号类型，所有的表示整数的类型都是有符号类型，因此需要区分算术右移和逻辑右移。在**Java** 中，算术右移的符号是 >>，逻辑右移的符号是 >>>。



### 移位运算与乘除法的关系

观察上面的例子可以看到，移位运算与乘除法有密切的关联性。由于计算机的底层的一切运算都是基于位运算实现的，因此使用移位运算实现乘除法的效率显著高于直接乘除法的效率。



左移运算对应乘法运算。将一个数左移 kk 位，等价于将这个数乘以 ![img](https://cdn.nlark.com/yuque/__latex/fe401f62231ac24e3399751a415a4eaa.svg)。例如，29 左移 2 位的结果是 116，等价于 ![img](https://cdn.nlark.com/yuque/__latex/cd4649f7310f516bfe5851bd1f08361c.svg)。当乘数不是 2 的整数次幂时，可以将乘数拆成若干项 2 的整数次幂之和，例如，![img](https://cdn.nlark.com/yuque/__latex/a9d57a34a8eda11fab115a1a48c922fe.svg) 等价于 (a<<2)+(a<<1)。对于任意整数，乘法运算都可以用左移运算实现，但是需要注意溢出的情况，例如在 8 位二进制表示下，29 左移 3 位就会出现溢出。



算术右移运算对应除法运算。将一个数右移 k 位，相当于将这个数除以 ![img](https://cdn.nlark.com/yuque/__latex/fe401f62231ac24e3399751a415a4eaa.svg)。例如，50 右移 2 位的结果是 12，等价于 50/4，结果向下取整。



从程序实现的角度，考虑程序中的整数除法，是否可以说，将一个数（算术）右移 k 位，和将这个数除以 ![img](https://cdn.nlark.com/yuque/__latex/fe401f62231ac24e3399751a415a4eaa.svg)等价？对于 0 和正数，上述说法是成立的，整数除法是向 0 取整，右移运算是向下取整，也是向 0 取整。但是对于负数，上述说法就不成立了，整数除法是向 0 取整，右移运算是向下取整，两者就不相同了。例如，(−50)>>2 的结果是 -13，而 (−50)/4 的结果是 -12，两者是不相等的。

因此，将一个数（算术）右移 k 位，和将这个数除以 ![img](https://cdn.nlark.com/yuque/__latex/fe401f62231ac24e3399751a415a4eaa.svg)是不等价的。



## 位运算的性质

位运算的性质有很多，此处列举位运算中的与、或、异或和取反的常见性质。假设以下出现的变量都是有符号整数。



- 幂等律：![img](https://cdn.nlark.com/yuque/__latex/93b741360741e64a92b022939c705f67.svg)（注意异或不满足幂等律）；



- 交换律：![img](https://cdn.nlark.com/yuque/__latex/a8943d3f85d55daf6a657c49b8039efc.svg)；



- 结合律：![img](https://cdn.nlark.com/yuque/__latex/b23c196d105be26eeab8d2df12f5e98a.svg)；



- 分配律：![img](https://cdn.nlark.com/yuque/__latex/cf1fe5406135732400d96cf315e5a0b2.svg)；
- 德·摩根律：![img](https://cdn.nlark.com/yuque/__latex/e0fedd195505857d66bb9036a990fddb.svg)；



- 取反运算性质：![img](https://cdn.nlark.com/yuque/__latex/7cd1b88c895c37abfc3e2adb312bfba0.svg)；



- 与运算性质：![img](https://cdn.nlark.com/yuque/__latex/e3d19dfd638321e7b26037033286b8f3.svg)；



- 或运算性质：![img](https://cdn.nlark.com/yuque/__latex/6c0d3085c370d04350ec5f9e832fe0b1.svg)；



- 异或运算性质：![img](https://cdn.nlark.com/yuque/__latex/c49d997024d7dccba4cd33eb2203afc5.svg)；



- 其他性质：



- - ![img](https://cdn.nlark.com/yuque/__latex/e7c2f2238360cb6e8e8fb706f3def481.svg) 的结果为将 ![img](https://cdn.nlark.com/yuque/__latex/0cc175b9c0f1b6a831c399e269772661.svg) 的二进制表示的最后一个 1 变成 0；
  - ![img](https://cdn.nlark.com/yuque/__latex/1e4cfd61a4907f79958724c01566ebf7.svg)（与 ![img](https://cdn.nlark.com/yuque/__latex/453596ffca49ca157618f76120968ffe.svg) 等价）的结果为只保留 ![img](https://cdn.nlark.com/yuque/__latex/0cc175b9c0f1b6a831c399e269772661.svg) 的二进制表示的最后一个 1，其余的 1 都变成 0。



利用上述性质，可以巧妙地解决很多位运算的题目。
